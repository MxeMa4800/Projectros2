1.upload code Arduino
2.open terminal --> roscore
3.open terminal --> rosrun rosserial_python serial_node.py _port:=/dev/ttyUSB0 _baud:=57600
4.open terminal --> roslaunch my_mobile_robot gmap_lidar.launch
5.open terminal --> rqt
6.open terminal --> rosrun map_server map_saver -f 
7.move file(2file) to my_mobile_robot/maps
///////8.roslaunch my_mobile_robot amcl_move_base_pro.launch 
8.roslaunch my_mobile_robot amcl_nomap.launch
9.test rqt or pose 2D






Arduino Code

//Full code ros cmd_vel, PID, no pub

// #include <PID_v1.h>
// #include <Encoder.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>
#include <std_msgs/String.h>

#define WHEEL_DISTANCE 0.195

// Initialize ROS node
ros::NodeHandle nh;

// Buffer for string message
char str_msg_buffer[50];

// Initialize string message
std_msgs::String str_msg;

// Publisher for monitoring cmd_vel
// ros::Publisher cmd_vel_monitor("cmd_vel_monitor", &str_msg);

// Define constants
#define ENCODER_A_LEFT 2
#define ENCODER_B_LEFT 4
#define ENCODER_A_RIGHT 3
#define ENCODER_B_RIGHT 8
#define MOTOR_LEFT_IN1 5
#define MOTOR_LEFT_IN2 6
#define MOTOR_RIGHT_IN1 9
#define MOTOR_RIGHT_IN2 10
#define MAX_SPEED 255

//960 ticks per round 213 mm
// Wheel Diameter 68mm
// PI*68 = 213.714 mm
// Define variables

volatile long left_encoder_ticks = 0;
volatile long right_encoder_ticks = 0;

//setpoit speed tick/DT : ticks/50ms >> (ticks*214*10^-3/(960))/(50*10^-3) m/s
//setpoint speed m/s = setpoint_ticks * 0.004458333
#define mps_ticks 224.299082191 // 1/0.004458333

//!!!!!!! MODIFY SPEED HERE in m/s
#define LSPEED 0.0
#define RSPEED 0.0
double left_speed_setpoint = LSPEED * mps_ticks;
double right_speed_setpoint = RSPEED * mps_ticks;

//pid out
double left_motor_output = 0;
double right_motor_output = 0;

double left_speed_actual = 0;
double right_speed_actual = 0;
unsigned long last_time = 0;
#define DT 50 // PID control interval

double Kp = 5.0; // Proportional gain
double Ki = 0.001; // Integral gain
double Kd = 0.001; // Derivative gain

// Callback function for cmd_vel messages
void cmdVelCallback(const geometry_msgs::Twist& msg) {
// Extract linear and angular velocities
float linearVel = msg.linear.x;
float angularVel = msg.angular.z;

// Calculate motor speeds based on the robot's wheel distance
left_speed_setpoint = (linearVel - (WHEEL_DISTANCE * angularVel) / 2)*mps_ticks;
right_speed_setpoint = (linearVel + (WHEEL_DISTANCE * angularVel) / 2)*mps_ticks;

// // Convert float values to strings
// char linearStr[10];
// char angularStr[10];
// dtostrf(linearVel, 6, 2, linearStr);
// dtostrf(angularVel, 6, 2, angularStr);

// // Format the cmd_vel message into a string
// snprintf(str_msg_buffer, sizeof(str_msg_buffer), "Linear:%s Angular:%s", linearStr, angularStr);
// str_msg.data = str_msg_buffer;

// // Publish the string message
// cmd_vel_monitor.publish(&str_msg);
}

// Initialize cmd_vel subscriber
ros::Subscriber<geometry_msgs::Twist> cmdVelSub("cmd_vel", cmdVelCallback);

// Setup function
void setup() {
// Serial.begin(1000000); // open the serial port at 9600 bps:
// Serial.println("Start Diff Drive Ros");
// nh.getHardware()->setBaud(115200); // Set baud rate to 1 Mbps
//nh.getHardware()->setBaud(1000000); 
nh.initNode();
nh.subscribe(cmdVelSub);
// nh.advertise(cmd_vel_monitor);

pinMode(MOTOR_LEFT_IN1, OUTPUT);
pinMode(MOTOR_LEFT_IN2, OUTPUT);
pinMode(MOTOR_RIGHT_IN1, OUTPUT);
pinMode(MOTOR_RIGHT_IN2, OUTPUT);
attachInterrupt(digitalPinToInterrupt(ENCODER_A_LEFT), leftEncoderISR, RISING);
pinMode(ENCODER_B_LEFT, INPUT);
attachInterrupt(digitalPinToInterrupt(ENCODER_A_RIGHT), rightEncoderISR, RISING);
pinMode(ENCODER_B_RIGHT, INPUT);

}
double integral_left, integral_right, prev_error_left, prev_error_right;

void pidControlLoop() {
// Read encoder values (AB encoders)
// Calculate current left and right wheel speeds (in m/s)

// Calculate errors
double error_left = left_speed_setpoint - left_speed_actual;
double error_right = right_speed_setpoint - right_speed_actual;

// Update integral terms
integral_left += error_left;
integral_right += error_right;

// Calculate PID control outputs
double control_output_left = Kp * error_left + Ki * integral_left + Kd * (error_left - prev_error_left);
double control_output_right = Kp * error_right + Ki * integral_right + Kd * (error_right - prev_error_right);


setLeftMotorSpeed(control_output_left);
setRightMotorSpeed(control_output_right);

// Serial.print("PID out L: ");
// Serial.print(control_output_left);
// Serial.print("\tspeed L :");
// Serial.println(left_speed_actual);

// Serial.print("PID out r: ");
// Serial.print(control_output_right);
// Serial.print("\tspeed R :");
// Serial.println(right_speed_actual);


// Update previous errors
prev_error_left = error_left;
prev_error_right = error_right;
}

// Loop function
void loop() {
nh.spinOnce();

unsigned long current_time = millis();
if (current_time - last_time >= DT) {

left_speed_actual = left_encoder_ticks; // Convert encoder ticks to speed (assuming 10 ms interval)
right_speed_actual = right_encoder_ticks; // Convert encoder ticks to speed (assuming 10 ms interval)
pidControlLoop();

last_time = current_time;
left_encoder_ticks = 0;
right_encoder_ticks = 0;
}
delay(5);
}

// Interrupt service routine for left encoder
void leftEncoderISR() {
int encoder_b_left_state = digitalRead(ENCODER_B_LEFT);
// Increment or decrement left_encoder_ticks based on the state

if (encoder_b_left_state == HIGH) {
left_encoder_ticks++;
} else {
left_encoder_ticks--;
}
}

// Interrupt service routine for right encoder
void rightEncoderISR() {
int encoder_b_right_state = digitalRead(ENCODER_B_RIGHT);

if (encoder_b_right_state == LOW) {
right_encoder_ticks++;
} else {
right_encoder_ticks--;
}
}

// Function to set left motor speed
void setLeftMotorSpeed(int speed) {
if (speed > 0) {
digitalWrite(MOTOR_LEFT_IN1, HIGH);
digitalWrite(MOTOR_LEFT_IN2, LOW);
if (speed > MAX_SPEED) speed = MAX_SPEED;
analogWrite(MOTOR_LEFT_IN1, speed);
} else if (speed < 0) {
speed = -speed;
digitalWrite(MOTOR_LEFT_IN1, LOW);
digitalWrite(MOTOR_LEFT_IN2, HIGH);
if (speed > MAX_SPEED) speed = MAX_SPEED;
analogWrite(MOTOR_LEFT_IN2, speed);
} else {
digitalWrite(MOTOR_LEFT_IN1, LOW);
digitalWrite(MOTOR_LEFT_IN2, LOW);
analogWrite(MOTOR_LEFT_IN1, 0);
}
}

// Function to set right motor speed
void setRightMotorSpeed(int speed) {
if (speed > 0) {
digitalWrite(MOTOR_RIGHT_IN1, HIGH);
digitalWrite(MOTOR_RIGHT_IN2, LOW);
if (speed > 255) speed = 255;
analogWrite(MOTOR_RIGHT_IN1, speed);
} else if (speed < 0) {
speed = -speed;
digitalWrite(MOTOR_RIGHT_IN1, LOW);
digitalWrite(MOTOR_RIGHT_IN2, HIGH);
if (speed > 255) speed = 255;
analogWrite(MOTOR_RIGHT_IN2, speed);
} else {
digitalWrite(MOTOR_RIGHT_IN1, LOW);
digitalWrite(MOTOR_RIGHT_IN2, LOW);
analogWrite(MOTOR_RIGHT_IN1, 0);
}
}








//Full code ros cmd_vel, PID, no pub

// #include <PID_v1.h>
// #include <Encoder.h>
#include <ros.h>
#include <geometry_msgs/Twist.h>
#include <std_msgs/String.h>

#define WHEEL_DISTANCE 0.21

// Initialize ROS node
ros::NodeHandle nh;

// Buffer for string message
char str_msg_buffer[50];

// Initialize string message
std_msgs::String str_msg;

// Publisher for monitoring cmd_vel
// ros::Publisher cmd_vel_monitor("cmd_vel_monitor", &str_msg);

// Define constants
#define ENCODER_A_RIGHT 2
#define ENCODER_B_RIGHT 4
#define ENCODER_A_LEFT 3
#define ENCODER_B_LEFT 8
#define MOTOR_RIGHT_IN1 5
#define MOTOR_RIGHT_IN2 6
#define MOTOR_LEFT_IN1 9
#define MOTOR_LEFT_IN2 10
#define MAX_SPEED 255

//960 ticks per round 213 mm
// Wheel Diameter 68mm
// PI*68 = 213.714 mm
// Define variables

volatile long left_encoder_ticks = 0;
volatile long right_encoder_ticks = 0;

//setpoit speed tick/DT : ticks/50ms >> (ticks*214*10^-3/(960))/(50*10^-3) m/s
//setpoint speed m/s = setpoint_ticks * 0.004458333
#define mps_ticks 224.299082191 // 1/0.004458333

//!!!!!!! MODIFY SPEED HERE in m/s
#define LSPEED 0.0
#define RSPEED 0.0
double left_speed_setpoint = LSPEED * mps_ticks;
double right_speed_setpoint = RSPEED * mps_ticks;

//pid out
double left_motor_output = 0;
double right_motor_output = 0;

double left_speed_actual = 0;
double right_speed_actual = 0;
unsigned long last_time = 0;
#define DT 50 // PID control interval

double Kp = 5.0; // Proportional gain
double Ki = 0.0; // Integral gain
double Kd = 0.01; // Derivative gain

// Callback function for cmd_vel messages
void cmdVelCallback(const geometry_msgs::Twist& msg) {
// Extract linear and angular velocities
float linearVel = msg.linear.x;
float angularVel = msg.angular.z;

// Calculate motor speeds based on the robot's wheel distance
left_speed_setpoint = (linearVel - (WHEEL_DISTANCE * angularVel) / 2)*mps_ticks;
right_speed_setpoint = (linearVel + (WHEEL_DISTANCE * angularVel) / 2)*mps_ticks;

// // Convert float values to strings
// char linearStr[10];
// char angularStr[10];
// dtostrf(linearVel, 6, 2, linearStr);
// dtostrf(angularVel, 6, 2, angularStr);

// // Format the cmd_vel message into a string
// snprintf(str_msg_buffer, sizeof(str_msg_buffer), "Linear:%s Angular:%s", linearStr, angularStr);
// str_msg.data = str_msg_buffer;

// // Publish the string message
// cmd_vel_monitor.publish(&str_msg);
}

// Initialize cmd_vel subscriber
ros::Subscriber<geometry_msgs::Twist> cmdVelSub("cmd_vel", cmdVelCallback);

// Setup function
void setup() {
// Serial.begin(1000000); // open the serial port at 9600 bps:
// Serial.println("Start Diff Drive Ros");
// nh.getHardware()->setBaud(115200); // Set baud rate to 1 Mbps
//nh.getHardware()->setBaud(1000000); 
nh.initNode();
nh.subscribe(cmdVelSub);
// nh.advertise(cmd_vel_monitor);

pinMode(MOTOR_LEFT_IN1, OUTPUT);
pinMode(MOTOR_LEFT_IN2, OUTPUT);
pinMode(MOTOR_RIGHT_IN1, OUTPUT);
pinMode(MOTOR_RIGHT_IN2, OUTPUT);
attachInterrupt(digitalPinToInterrupt(ENCODER_A_LEFT), leftEncoderISR, RISING);
pinMode(ENCODER_B_LEFT, INPUT);
attachInterrupt(digitalPinToInterrupt(ENCODER_A_RIGHT), rightEncoderISR, RISING);
pinMode(ENCODER_B_RIGHT, INPUT);

}
double integral_left, integral_right, prev_error_left, prev_error_right;

void pidControlLoop() {
// Read encoder values (AB encoders)
// Calculate current left and right wheel speeds (in m/s)

// Calculate errors
double error_left = left_speed_setpoint - left_speed_actual;
double error_right = right_speed_setpoint - right_speed_actual;

// Update integral terms
integral_left += error_left;
integral_right += error_right;

// Calculate PID control outputs
double control_output_left = Kp * error_left + Ki * integral_left + Kd * (error_left - prev_error_left);
double control_output_right = Kp * error_right + Ki * integral_right + Kd * (error_right - prev_error_right);


setLeftMotorSpeed(control_output_left);
setRightMotorSpeed(control_output_right);

// Serial.print("PID out L: ");
// Serial.print(control_output_left);
// Serial.print("\tspeed L :");
// Serial.println(left_speed_actual);

// Serial.print("PID out r: ");
// Serial.print(control_output_right);
// Serial.print("\tspeed R :");
// Serial.println(right_speed_actual);


// Update previous errors
prev_error_left = error_left;
prev_error_right = error_right;
}

// Loop function
void loop() {
nh.spinOnce();

unsigned long current_time = millis();
if (current_time - last_time >= DT) {

left_speed_actual = left_encoder_ticks; // Convert encoder ticks to speed (assuming 10 ms interval)
right_speed_actual = right_encoder_ticks; // Convert encoder ticks to speed (assuming 10 ms interval)
pidControlLoop();

last_time = current_time;
left_encoder_ticks = 0;
right_encoder_ticks = 0;
}
delay(5);
}

// Interrupt service routine for left encoder
void leftEncoderISR() {
int encoder_b_left_state = digitalRead(ENCODER_B_LEFT);
// Increment or decrement left_encoder_ticks based on the state

if (encoder_b_left_state == HIGH) {
left_encoder_ticks++;
} else {
left_encoder_ticks--;
}
}

// Interrupt service routine for right encoder
void rightEncoderISR() {
int encoder_b_right_state = digitalRead(ENCODER_B_RIGHT);

if (encoder_b_right_state == LOW) {
right_encoder_ticks++;
} else {
right_encoder_ticks--;
}
}

// Function to set left motor speed
void setLeftMotorSpeed(int speed) {
if (speed > 0) {
digitalWrite(MOTOR_LEFT_IN1, HIGH);
digitalWrite(MOTOR_LEFT_IN2, LOW);
if (speed > MAX_SPEED) speed = MAX_SPEED;
analogWrite(MOTOR_LEFT_IN1, speed);
} else if (speed < 0) {
speed = -speed;
digitalWrite(MOTOR_LEFT_IN1, LOW);
digitalWrite(MOTOR_LEFT_IN2, HIGH);
if (speed > MAX_SPEED) speed = MAX_SPEED;
analogWrite(MOTOR_LEFT_IN2, speed);
} else {
digitalWrite(MOTOR_LEFT_IN1, LOW);
digitalWrite(MOTOR_LEFT_IN2, LOW);
analogWrite(MOTOR_LEFT_IN1, 0);
}
}

// Function to set right motor speed
void setRightMotorSpeed(int speed) {
if (speed > 0) {
digitalWrite(MOTOR_RIGHT_IN1, HIGH);
digitalWrite(MOTOR_RIGHT_IN2, LOW);
if (speed > 255) speed = 255;
analogWrite(MOTOR_RIGHT_IN1, speed);
} else if (speed < 0) {
speed = -speed;
digitalWrite(MOTOR_RIGHT_IN1, LOW);
digitalWrite(MOTOR_RIGHT_IN2, HIGH);
if (speed > 255) speed = 255;
analogWrite(MOTOR_RIGHT_IN2, speed);
} else {
digitalWrite(MOTOR_RIGHT_IN1, LOW);
digitalWrite(MOTOR_RIGHT_IN2, LOW);
analogWrite(MOTOR_RIGHT_IN1, 0);
}
}



































